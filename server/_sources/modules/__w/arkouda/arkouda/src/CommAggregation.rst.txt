.. default-domain:: chpl

.. module:: CommAggregation

CommAggregation
===============
**Usage**

.. code-block:: chapel

   use CommAggregation;


or

.. code-block:: chapel

   import CommAggregation;

**Submodules**

.. toctree::
   :maxdepth: 1
   :glob:

   CommAggregation/*

.. function:: proc newDstAggregator(type elemType, param useUnorderedCopy = false)

   Creates a new destination aggregator (dst/lhs will be remote). 

.. function:: proc newSrcAggregator(type elemType, param useUnorderedCopy = false)

   Creates a new source aggregator (src/rhs will be remote). 

.. record:: DstAggregator

   
   * Aggregates copy(ref dst, src). Optimized for when src is local.
   * Not parallel safe and is expected to be created on a per-task basis
   * High memory usage since there are per-destination buffers
   


   .. attribute:: type elemType

   .. attribute:: type aggType = (c_ptr(elemType), elemType)

   .. attribute:: const bufferSize = dstBuffSize

   .. attribute:: const myLocaleSpace = 0..<numLocales

   .. attribute:: var lastLocale: int

   .. attribute:: var opsUntilYield = yieldFrequency

   .. attribute:: var lBuffers: c_ptr(c_ptr(aggType))

   .. attribute:: var rBuffers: [myLocaleSpace] remoteBuffer(aggType)

   .. attribute:: var bufferIdxs: c_ptr(int)

   .. method:: proc ref postinit()

   .. method:: proc ref deinit()

   .. method:: proc ref flush()

   .. method:: proc ref copy(ref dst: elemType, const in srcVal: elemType)

   .. method:: proc ref _flushBuffer(loc: int, ref bufferIdx, freeData)

.. record:: DstUnorderedAggregator

   "Aggregator" that uses unordered copy instead of actually aggregating 


   .. attribute:: type elemType

   .. method:: proc deinit()

   .. method:: proc flush()

   .. method:: proc copy(ref dst: elemType, const in srcVal: elemType)

.. record:: SrcAggregator

   
   * Aggregates copy(ref dst, const ref src). Only works when dst is local.
   * Not parallel safe and is expected to be created on a per task basis
   * High memory usage since there are per-destination buffers
   


   .. attribute:: type elemType

   .. attribute:: type aggType = c_ptr(elemType)

   .. attribute:: const bufferSize = srcBuffSize

   .. attribute:: const myLocaleSpace = 0..<numLocales

   .. attribute:: var lastLocale: int

   .. attribute:: var opsUntilYield = yieldFrequency

   .. attribute:: var dstAddrs: c_ptr(c_ptr(aggType))

   .. attribute:: var lSrcAddrs: c_ptr(c_ptr(aggType))

   .. attribute:: var lSrcVals: [myLocaleSpace] [0..#bufferSize] elemType

   .. attribute:: var rSrcAddrs: [myLocaleSpace] remoteBuffer(aggType)

   .. attribute:: var rSrcVals: [myLocaleSpace] remoteBuffer(elemType)

   .. attribute:: var bufferIdxs: c_ptr(int)

   .. method:: proc ref postinit()

   .. method:: proc ref deinit()

   .. method:: proc ref flush()

   .. method:: proc ref copy(ref dst: elemType, const ref src: elemType)

   .. method:: proc ref _flushBuffer(loc: int, ref bufferIdx, freeData)

.. record:: SrcUnorderedAggregator

   "Aggregator" that uses unordered copy instead of actually aggregating 


   .. attribute:: type elemType

   .. method:: proc deinit()

   .. method:: proc flush()

   .. method:: proc copy(ref dst: elemType, const ref src: elemType)

.. record:: remoteBuffer

   .. attribute:: type elemType

   .. attribute:: var size: int

   .. attribute:: var loc: int

   .. attribute:: var data: c_ptr(elemType)

   .. method:: proc ref cachedAlloc(): c_ptr(elemType)

   .. itermethod:: iter localIter(data: c_ptr(elemType), size: int) ref: elemType

   .. method:: proc localFree(data: c_ptr(elemType))

   .. method:: proc ref markFreed()

   .. method:: proc PUT(lArr: [] elemType, size: int)

   .. method:: proc PUT(lArr: c_ptr(elemType), size: int)

   .. method:: proc ref GET(ref lArr: [] elemType, size: int)

   .. method:: proc ref deinit()

.. function:: proc bufferIdxAlloc()

