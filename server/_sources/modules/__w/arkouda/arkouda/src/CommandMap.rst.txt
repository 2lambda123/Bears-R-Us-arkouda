.. default-domain:: chpl

.. module:: CommandMap

CommandMap
==========
**Usage**

.. code-block:: chapel

   use CommandMap;


or

.. code-block:: chapel

   import CommandMap;

.. function:: proc akMsgSign(cmd: string, payload: string, argSize: int, st: borrowed SymTab): MsgTuple throws

   *
   * This is a dummy function to get the signature of the Arkouda
   * server FCF. Ideally, the `func()` function would be able to
   * construct the FCF type, but there is no way to generate a
   * FCF that throws using `func()` today.
   

.. function:: proc akBinMsgSign(cmd: string, payload: string, argSize: int, st: borrowed SymTab): bytes throws

   *
   * Just like akMsgSign, but Messages which have a binary return
   * require a different signature
   

.. data:: var commandMap: map(string, f.type)

.. data:: var commandMapBinary: map(string, b.type)

.. data:: var moduleMap: map(string, string)

.. data:: var usedModules: set(string)

.. function:: proc registerFunction(cmd: string, fcf: f.type)

   *
   * Register command->function in the CommandMap
   * This binds a server command to its corresponding function matching the standard
   * function signature & MsgTuple return type
   

.. function:: proc registerFunction(cmd: string, fcf: f.type, modName: string)

.. function:: proc writeUsedModules()

.. function:: proc registerBinaryFunction(cmd: string, fcf: b.type)

   *
   * Register command->function in the CommandMap for Binary returning functions
   * This binds a server command to its corresponding function matching the standard
   * function signature but returning "bytes"
   

.. function:: proc registerBinaryFunction(cmd: string, fcf: b.type, modName: string)

.. function:: proc dumpCommandMap(): string throws

   *
   * Dump the combined contents of the command maps as a single json encoded string
   

.. function:: proc executeCommand(cmd: string, args, argSize, st) throws

