.. default-domain:: chpl

.. module:: MsgProcessing

MsgProcessing
=============
**Usage**

.. code-block:: chapel

   use MsgProcessing;


or

.. code-block:: chapel

   import MsgProcessing;

.. data:: const mpLogger = new Logger(logLevel, logChannel)

.. function:: proc createMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab, param nd: int): MsgTuple throws

    
   Parse, execute, and respond to a create message 
   
   :arg : payload
   :type string: containing (dtype,size)
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (MsgTuple) response message
   

.. function:: proc createMsg0D(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

.. function:: proc deleteMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

    
   Parse, execute, and respond to a delete message 
   
   :arg reqMsg: request containing (cmd,name)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: MsgTuple
   

.. function:: proc clearMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

    
   Clear all unregistered symbols and associated data from sym table
   
   :arg reqMsg: request containing (cmd)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: MsgTuple
    

.. function:: proc infoMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

    
   Takes the name of data referenced in a msg and searches for the name in the provided sym table.
   Returns a string of info for the sym entry that is mapped to the provided name.
   
   :arg reqMsg: request containing (cmd,name)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: MsgTuple
    

.. function:: proc getconfigMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

    
   query server configuration...
   
   :arg reqMsg: request containing (cmd)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: MsgTuple
    

.. function:: proc getmemusedMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

    
   query server total memory allocated or symbol table data memory
   
   :arg reqMsg: request containing (cmd)
   :type reqMsg: string
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab
   
   :returns: MsgTuple
   

.. function:: proc getmemavailMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

   
   query server total memory availble
   
   :arg reqMsg: request containing (cmd)
   :type reqMsg: string
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab
   
   :returns: MsgTuple
   

.. function:: proc getCommandMapMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab) throws

   *
   * Generate the mapping of server command to function as JSON
   * encoded string.
   *
   * The args are IGNORED. They are only here to match the CommandMap
   * standard function signature, similar to other procs.
   *
   * :arg cmd: Ignored
   * :type cmd: string 
   *
   * :arg payload: Ignored
   * :type payload: string
   *
   * :arg st: Ignored
   * :type st: borrowed SymTab 
   *
   * :returns: MsgTuple containing JSON formatted string of cmd -> function mapping
   

.. function:: proc strMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

    
   Response to __str__ method in python str convert array data to string 
   
   :arg reqMsg: request containing (cmd,name)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string,MsgType)
   

.. function:: proc reprMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

   Response to __repr__ method in python.
   Repr convert array data to string 
   
   :arg reqMsg: request containing (cmd,name)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: MsgTuple
   

.. function:: proc setMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab, param nd = 1): MsgTuple throws

    
   Sets all elements in array to a value (broadcast) 
   
   :arg reqMsg: request containing (cmd,name,dtype,value)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: MsgTuple
   :throws: `UndefinedSymbolError(name)`
   

.. function:: proc broadcastNDArray(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab, param ndIn: int, param ndOut: int): MsgTuple throws

   
   Create a "broadcasted" array (of rank 'nd') by copying an array into an
   array of the given shape.
   
   E.g., given the following broadcast:
   A      (4d array):  8 x 1 x 6 x 1
   B      (3d array):      7 x 1 x 5
   ---------------------------------
   Result (4d array):  8 x 7 x 6 x 5
   
   Two separate calls would be made to store 'A' and 'B' in arrays with
   result's shape.
   
   When copying from a singleton dimension, the value is repeated along
   that dimension (e.g., A's 1st and 3rd, or B's 2nd dimension above).
   For non singleton dimensions, the size of the two arrays must match,
   and the values are copied into the result array.
   
   When prepending a new dimension to increase an array's rank, the
   values from the other dimensions are repeated along the new dimension.
   
   !!! TODO: Avoid the promoted copies here by leaving the singleton
   dimensions in the result array, and making operations on arrays
   aware that promotion of singleton dimensions may be necessary. E.g.,
   make matrix multiplication aware that it can treat a singleton
   value as a vector of the appropriate length during multiplication.
   
   (this may require a modification of SymEntry to keep track of
   which dimensions are explicitly singletons)
   
   NOTE: registration of this procedure is handled specially in
   'serverModuleGen.py' because it has two param fields. The purpose of
   designing "broadcast" this way is to avoid the the need for multiple
   dimensionality param fields in **all** other message handlers (e.g.,
   matrix multiply can be designed to expect matrices of equal rank,
   requiring only one dimensionality param field. As such, the client
   implementation of matrix-multiply may be required to broadcast the array
   arguments up to some common rank (N) before issuing a 'matMult{N}D'
   command to the server)
   

.. function:: proc checkValidBroadcast(from: ?Nf*int, to: ?Nt*int): (bool, Nf*bool)

