:py:mod:`arkouda.segarray`
==========================

.. py:module:: arkouda.segarray


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   arkouda.segarray.SegArray



Functions
~~~~~~~~~

.. autoapisummary::

   arkouda.segarray.gen_ranges
   arkouda.segarray._aggregator



.. py:function:: gen_ranges(starts, ends, stride=1)

   Generate a segmented array of variable-length, contiguous ranges between pairs of start- and end-points.

   :param starts:
   :type starts: pdarray, int64
   :param The start value of each range:
   :param ends:
   :type ends: pdarray, int64
   :param The end value (exclusive) of each range:
   :param stride:
   :type stride: int
   :param Difference between successive elements of each range:

   :returns: * **segments** (*pdarray, int64*)
             * *The starting index of each range in the resulting array*
             * **ranges** (*pdarray, int64*)
             * *The actual ranges, flattened into a single array*


.. py:function:: _aggregator(func)


.. py:class:: SegArray(segments, values, copy=False, lengths=None, grouping=None)

   .. py:method:: from_multi_array(cls, m)
      :classmethod:

      Construct a SegArray from a list of columns. This essentially transposes the input,
      resulting in an array of rows.

      :param m: List of columns, the rows of which will form the sub-arrays of the output
      :type m: list of pdarray

      :returns: Array of rows of input
      :rtype: SegArray


   .. py:method:: concat(cls, x, axis=0, ordered=True)
      :classmethod:

      Concatenate a sequence of SegArrays

      :param x: The SegArrays to concatenate
      :type x: sequence of SegArray
      :param axis: Select vertical (0) or horizontal (1) concatenation. If axis=1, all
                   SegArrays must have same size.
      :type axis: 0 or 1
      :param ordered: Must be True. This option is present for compatibility only, because unordered
                      concatenation is not yet supported.
      :type ordered: bool

      :returns: The input arrays joined into one SegArray
      :rtype: SegArray


   .. py:method:: copy(self)

      Return a deep copy.


   .. py:method:: _get_lengths(self)


   .. py:method:: __getitem__(self, i)


   .. py:method:: __eq__(self, other)

      Return self==value.


   .. py:method:: __str__(self)

      Return str(self).


   .. py:method:: __repr__(self)

      Return repr(self).


   .. py:method:: get_suffixes(self, n, return_origins=True, proper=True)

      Return the n-long suffix of each sub-array, where possible

      :param n: Length of suffix
      :type n: int
      :param return_origins: If True, return a logical index indicating which sub-arrays
                             were long enough to return an n-suffix
      :type return_origins: bool
      :param proper: If True, only return proper suffixes, i.e. from sub-arrays
                     that are at least n+1 long. If False, allow the entire
                     sub-array to be returned as a suffix.
      :type proper: bool

      :returns: * **suffixes** (*list of pdarray*) -- An n-long list of pdarrays, essentially a table where each row is an n-suffix.
                  The number of rows is the number of True values in the returned mask.
                * **origin_indices** (*pdarray, bool*) -- Boolean array that is True where the sub-array was long enough to return
                  an n-suffix, False otherwise.


   .. py:method:: get_prefixes(self, n, return_origins=True, proper=True)

      Return all sub-array prefixes of length n (for sub-arrays that are at least n+1 long)

      :param n: Length of suffix
      :type n: int
      :param return_origins: If True, return a logical index indicating which sub-arrays
                             were long enough to return an n-prefix
      :type return_origins: bool
      :param proper: If True, only return proper prefixes, i.e. from sub-arrays
                     that are at least n+1 long. If False, allow the entire
                     sub-array to be returned as a prefix.
      :type proper: bool

      :returns: * **prefixes** (*list of pdarray*) -- An n-long list of pdarrays, essentially a table where each row is an n-prefix.
                  The number of rows is the number of True values in the returned mask.
                * **origin_indices** (*pdarray, bool*) -- Boolean array that is True where the sub-array was long enough to return
                  an n-suffix, False otherwise.


   .. py:method:: get_ngrams(self, n, return_origins=True)

      Return all n-grams from all sub-arrays.

      :param n: Length of n-gram
      :type n: int
      :param return_origins: If True, return an int64 array indicating which sub-array
                             each returned n-gram came from.
      :type return_origins: bool

      :returns: * **ngrams** (*list of pdarray*) -- An n-long list of pdarrays, essentially a table where each row is an n-gram.
                * **origin_indices** (*pdarray, int*) -- The index of the sub-array from which the corresponding n-gram originated


   .. py:method:: _normalize_index(self, j)


   .. py:method:: get_jth(self, j, return_origins=True, compressed=False, default=0)

      Select the j-th element of each sub-array, where possible.

      :param j: The index of the value to get from each sub-array. If j is negative,
                it counts backwards from the end of each sub-array.
      :type j: int
      :param return_origins: If True, return a logical index indicating where j is in bounds
      :type return_origins: bool
      :param compressed: If False, return array is same size as self, with default value
                         where j is out of bounds. If True, the return array only contains
                         values where j is in bounds.
      :type compressed: bool
      :param default: When compressed=False, the value to return when j is out of bounds
                      for the sub-array
      :type default: scalar

      :returns: * **val** (*pdarray*) -- compressed=False: The j-th value of each sub-array where j is in
                  bounds and the default value where j is out of bounds.
                  compressed=True: The j-th values of only the sub-arrays where j is
                  in bounds
                * **origin_indices** (*pdarray, bool*) -- A Boolean array that is True where j is in bounds for the sub-array.


   .. py:method:: set_jth(self, i, j, v)

      Set the j-th element of each sub-array in a subset.

      :param i: Indices of sub-arrays to set j-th element
      :type i: pdarray, int
      :param j: Index of value to set in each sub-array. If j is negative, it counts
                backwards from the end of the sub-array.
      :type j: int
      :param v: The value(s) to set. If v is a pdarray, it must have same length as i.
      :type v: pdarray or scalar

      :raises ValueError: If j is out of bounds in any of the sub-arrays specified by i.


   .. py:method:: get_length_n(self, n, return_origins=True)

      Return all sub-arrays of length n, as a list of columns.

      :param n: Length of sub-arrays to select
      :type n: int
      :param return_origins: Return a logical index indicating which sub-arrays are length n
      :type return_origins: bool

      :returns: * **columns** (*list of pdarray*) -- An n-long list of pdarray, where each row is one of the n-long
                  sub-arrays from the SegArray. The number of rows is the number of
                  True values in the returned mask.
                * **origin_indices** (*pdarray, bool*) -- Array of bool for each element of the SegArray, True where sub-array
                  has length n.


   .. py:method:: append(self, other, axis=0)

      Append other to self, either vertically (axis=0, length of resulting SegArray
      increases), or horizontally (axis=1, each sub-array of other appends to the
      corresponding sub-array of self).

      :param other: Array of sub-arrays to append
      :type other: SegArray
      :param axis: Whether to append vertically (0) or horizontally (1). If axis=1, other
                   must be same size as self.
      :type axis: 0 or 1

      :returns: axis=0: New SegArray containing all sub-arrays
                axis=1: New SegArray of same length, with pairs of sub-arrays concatenated
      :rtype: SegArray


   .. py:method:: append_single(self, x, prepend=False)

      Append a single value to each sub-array.

      :param x: Single value to append to each sub-array
      :type x: pdarray or scalar

      :returns: Copy of original SegArray with values from x appended to each sub-array
      :rtype: SegArray


   .. py:method:: prepend_single(self, x)


   .. py:method:: remove_repeats(self, return_multiplicity=False)

      Condense sequences of repeated values within a sub-array to a single value.

      :param return_multiplicity: If True, also return the number of times each value was repeated.
      :type return_multiplicity: bool

      :returns: * **norepeats** (*SegArray*) -- Sub-arrays with runs of repeated values replaced with single value
                * **multiplicity** (*SegArray*) -- If return_multiplicity=True, this array contains the number of times
                  each value in the returned SegArray was repeated in the original SegArray.


   .. py:method:: to_ndarray(self)

      Convert the array into a numpy.ndarray containing sub-arrays

      :returns: A numpy ndarray with the same sub-arrays (also numpy.ndarray) as this array
      :rtype: np.ndarray

      .. seealso:: :obj:`array`

      .. rubric:: Examples

      >>> segarr = ak.SegArray(ak.array([0, 4, 7]), ak.arange(12))
      >>> segarr.to_ndarray()
      array([[1, 2, 3, 4], [5, 6, 7], [8, 9, 10, 11, 12]])
      >>> type(segarr.to_ndarray())
      numpy.ndarray


   .. py:method:: sum(self, x=None)


   .. py:method:: prod(self, x=None)


   .. py:method:: min(self, x=None)


   .. py:method:: max(self, x=None)


   .. py:method:: argmin(self, x=None)


   .. py:method:: argmax(self, x=None)


   .. py:method:: any(self, x=None)


   .. py:method:: all(self, x=None)


   .. py:method:: OR(self, x=None)


   .. py:method:: AND(self, x=None)


   .. py:method:: XOR(self, x=None)


   .. py:method:: nunique(self, x=None)


   .. py:method:: mean(self, x=None)


   .. py:method:: aggregate(self, op, x=None)


   .. py:method:: unique(self, x=None)

      Return sub-arrays of unique values.

      :param x: The values to unique, per group. By default, the values of this
                SegArray's sub-arrays.
      :type x: pdarray

      :returns: Same number of sub-arrays as original SegArray, but elements in sub-array
                are unique and in sorted order.
      :rtype: SegArray


   .. py:method:: save(self, prefix_path, dataset='segarray', segment_suffix='_segments', value_suffix='_values', mode='truncate')

      Save the SegArray to HDF5. The result is a collection of HDF5 files, one file
      per locale of the arkouda server, where each filename starts with prefix_path.

      :param prefix_path: Directory and filename prefix that all output files will share
      :type prefix_path: str
      :param dataset: Name prefix for saved data within the HDF5 file
      :type dataset: str
      :param segment_suffix: Suffix to append to dataset name for segments array
      :type segment_suffix: str
      :param value_suffix: Suffix to append to dataset name for values array
      :type value_suffix: str
      :param mode: By default, truncate (overwrite) output files, if they exist.
                   If 'append', add data as a new column to existing files.
      :type mode: str {'truncate' | 'append'}

      :rtype: None

      .. rubric:: Notes

      Unlike for ak.Strings, SegArray is saved as two datasets in the top level of
      the HDF5 file, not nested under a group.


   .. py:method:: load(cls, prefix_path, dataset='segarray', segment_suffix='_segments', value_suffix='_values', mode='truncate')
      :classmethod:

      Load a saved SegArray from HDF5. All arguments msut match what
      was supplied to SegArray.save()

      :param prefix_path: Directory and filename prefix
      :type prefix_path: str
      :param dataset: Name prefix for saved data within the HDF5 files
      :type dataset: str
      :param segment_suffix: Suffix to append to dataset name for segments array
      :type segment_suffix: str
      :param value_suffix: Suffix to append to dataset name for values array
      :type value_suffix: str

      :rtype: SegArray



