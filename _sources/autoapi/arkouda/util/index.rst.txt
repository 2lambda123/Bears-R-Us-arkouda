:py:mod:`arkouda.util`
======================

.. py:module:: arkouda.util


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   arkouda.util.attach
   arkouda.util.attach_all
   arkouda.util.broadcast_dims
   arkouda.util.concatenate
   arkouda.util.convert_bytes
   arkouda.util.convert_if_categorical
   arkouda.util.enrich_inplace
   arkouda.util.expand
   arkouda.util.generic_concat
   arkouda.util.get_callback
   arkouda.util.identity
   arkouda.util.invert_permutation
   arkouda.util.is_registered
   arkouda.util.most_common
   arkouda.util.register
   arkouda.util.register_all
   arkouda.util.report_mem
   arkouda.util.sparse_sum_help
   arkouda.util.unregister
   arkouda.util.unregister_all



.. py:function:: attach(name: str)


.. py:function:: attach_all(names: list)

   Attach to all objects registered with the names provide

   :param names: List of names to attach to
   :type names: list

   :rtype: dict


.. py:function:: broadcast_dims(sa: Sequence[int], sb: Sequence[int]) -> Tuple[int, Ellipsis]

   Algorithm to determine shape of broadcasted PD array given two array shapes

   see: https://data-apis.org/array-api/latest/API_specification/broadcasting.html#algorithm


.. py:function:: concatenate(items, ordered=True)


.. py:function:: convert_bytes(nbytes, unit='B')

   Convert the number of bytes to KB, MB, or GB.

   :param unit: Unit to return. One of {'B', 'KB', 'MB', 'GB'}.
   :type unit: str, default = "B"

   :rtype: int


.. py:function:: convert_if_categorical(values)

   Convert a Categorical array to Strings for display


.. py:function:: enrich_inplace(data, keynames, aggregations, **kwargs)


.. py:function:: expand(size, segs, vals)

   Expand an array with values placed into the indicated segments.

   :param size: The size of the array to be expanded
   :type size: ak.pdarray
   :param segs: The indices where the values should be placed
   :type segs: ak.pdarray
   :param vals: The values to be placed in each segment
   :type vals: ak.pdarray

   :returns: The expanded array.
   :rtype: pdarray

   .. rubric:: Notes

   This function (with different order of arguments) is now in arkouda
   proper as ak.broadcast. It is retained here for backwards compatibility.


.. py:function:: generic_concat(items, ordered=True)


.. py:function:: get_callback(x)


.. py:function:: identity(x)


.. py:function:: invert_permutation(perm)

   Find the inverse of a permutation array.

   :param perm: The permutation array.
   :type perm: ak.pdarray

   :returns: The inverse of the permutation array.
   :rtype: ak.array


.. py:function:: is_registered(name: str, as_component: bool = False) -> bool

   Determine if the name provided is associated with a registered Object

   :param name: The name to check for in the registry
   :type name: str
   :param as_component: Default: False
                        When True, the name will be checked to determine if it is registered as a component of
                        a registered object
   :type as_component: bool

   :rtype: bool


.. py:function:: most_common(g, values)


.. py:function:: register(obj, name)

   Register an arkouda object with a user-specified name. Backwards compatible
   with earlier arkouda versions.


.. py:function:: register_all(data: dict)

   Register all objects in the provided dictionary

   :param data: Maps name to register the object to the object. For example, {"MyArray": ak.array([0, 1, 2])
   :type data: dict

   :rtype: None


.. py:function:: report_mem(pre='')


.. py:function:: sparse_sum_help(idx1, idx2, val1, val2)

   Helper for summing two sparse matrices together

   :param idx1: indices for the first sparse matrix
   :type idx1: pdarray
   :param idx2: indices for the second sparse matrix
   :type idx2: pdarray
   :param val1: values for the first sparse matrix
   :type val1: pdarray
   :param val2: values for the second sparse matrix
   :type val2: pdarray

   :returns: indices and values for the summed sparse matrix
   :rtype: (pdarray, pdarray)

   .. rubric:: Examples

   >>> idx1 = ak.array([0, 1, 3, 4, 7, 9])
   >>> idx2 = ak.array([0, 1, 3, 6, 9])
   >>> vals1 = idx1
   >>> vals2 = ak.array([10, 11, 13, 16, 19])
   >>> ak.util.sparse_sum_help(idx1, inds2, vals1, vals2)
   (array([0 1 3 4 6 7 9]), array([10 12 16 4 16 7 28]))

   >>> ak.GroupBy(ak.concatenate([idx1, idx2])).sum(ak.concatenate((vals1, vals2)))
   (array([0 1 3 4 6 7 9]), array([10 12 16 4 16 7 28]))


.. py:function:: unregister(name: str) -> str


.. py:function:: unregister_all(names: list)

   Unregister all names provided

   :param names: List of names used to register objects to be unregistered
   :type names: list

   :rtype: None


