:py:mod:`arkouda.dataframe`
===========================

.. py:module:: arkouda.dataframe


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   arkouda.dataframe.DataFrame



Functions
~~~~~~~~~

.. autoapisummary::

   arkouda.dataframe.sorted
   arkouda.dataframe.intx
   arkouda.dataframe.intersect
   arkouda.dataframe.invert_permutation
   arkouda.dataframe.merge



.. py:class:: DataFrame(initialdata=None, index=None, columns=None)


   Bases: :py:obj:`collections.UserDict`

   A DataFrame structure based on arkouda arrays.

   :param initialdata: Each list/dictionary entry corresponds to one column of the data and
                       should be a homogenous type. Different columns may have different
                       types. If using a dictionary, keys should be strings.
   :type initialdata: List or dictionary of lists, tuples, or pdarrays
   :param index: Index for the resulting frame. Defaults to an integer range.
   :type index: Index, pdarray, or Strings
   :param columns: Column labels to use if the data does not include them. Elements must
                   be strings. Defaults to an stringified integer range.
   :type columns: List, tuple, pdarray, or Strings

   .. rubric:: Examples

   Create an empty DataFrame and add a column of data:

   >>> import arkouda as ak
   >>> import numpy as np
   >>> import pandas as pd
   >>> df = ak.DataFrame()
   >>> df['a'] = ak.array([1,2,3])

   Create a new DataFrame using a dictionary of data:

   >>> userName = ak.array(['Alice', 'Bob', 'Alice', 'Carol', 'Bob', 'Alice'])
   >>> userID = ak.array([111, 222, 111, 333, 222, 111])
   >>> item = ak.array([0, 0, 1, 1, 2, 0])
   >>> day = ak.array([5, 5, 6, 5, 6, 6])
   >>> amount = ak.array([0.5, 0.6, 1.1, 1.2, 4.3, 0.6])
   >>> df = ak.DataFrame({'userName': userName, 'userID': userID,
   >>>            'item': item, 'day': day, 'amount': amount})
   >>> df
   DataFrame(['userName', 'userID', 'item', 'day', 'amount'] [6 rows : 224 B])

   Indexing works slightly differently than with pandas:
   >>> df[0]
   {'userName': 'Alice', 'userID': 111, 'item': 0, 'day': 5, 'amount': 0.5}
   >>> df['userID']
   array([111, 222, 111, 333, 222, 111])
   >>> df['userName']
   array(['Alice', 'Bob', 'Alice', 'Carol', 'Bob', 'Alice'])
   >>> df[[1,5,7]]
     userName  userID  item  day  amount
   1      Bob     222     0    5     0.6
   2    Alice     111     1    6     1.1
   3    Carol     333     1    5     1.2

   Note that strides are not implemented except for stride = 1.
   >>> df[1:5:1]
   DataFrame(['userName', 'userID', 'item', 'day', 'amount'] [4 rows : 148 B])
   >>> df[ak.array([1,2,3])]
   DataFrame(['userName', 'userID', 'item', 'day', 'amount'] [3 rows : 112 B])
   >>> df[['userID', 'day']]
   DataFrame(['userID', 'day'] [6 rows : 96 B])

   .. py:property:: size

      Returns the number of bytes on the arkouda server.

   .. py:property:: dtypes


   .. py:property:: empty


   .. py:property:: shape


   .. py:property:: columns


   .. py:property:: index


   .. py:property:: info

      Returns a summary string of this dataframe.

   .. py:attribute:: COLUMN_CLASSES
      :value: ()

      

   .. py:attribute:: objType
      :value: 'DataFrame'

      

   .. py:method:: transfer(hostname, port)

      Sends a DataFrame to a different Arkouda server

      :param hostname: The hostname where the Arkouda server intended to
                       receive the DataFrame is running.
      :type hostname: str
      :param port: The port to send the array over. This needs to be an
                   open port (i.e., not one that the Arkouda server is
                   running on). This will open up `numLocales` ports,
                   each of which in succession, so will use ports of the
                   range {port..(port+numLocales)} (e.g., running an
                   Arkouda server of 4 nodes, port 1234 is passed as
                   `port`, Arkouda will use ports 1234, 1235, 1236,
                   and 1237 to send the array data).
                   This port much match the port passed to the call to
                   `ak.receive_array()`.
      :type port: int_scalars

      :rtype: A message indicating a complete transfer

      :raises ValueError: Raised if the op is not within the pdarray.BinOps set
      :raises TypeError: Raised if other is not a pdarray or the pdarray.dtype is not
          a supported dtype


   .. py:method:: from_pandas(pd_df)
      :classmethod:


   .. py:method:: drop(keys: Union[str, int, List[Union[str, int]]], axis: Union[str, int] = 0, inplace: bool = False) -> Union[None, DataFrame]

      Drop column/s or row/s from the dataframe.

      :param keys: The labels to be dropped on the given axis
      :type keys: str, int or list
      :param axis: The axis on which to drop from. 0/'index' - drop rows, 1/'columns' - drop columns
      :type axis: int or str
      :param inplace: Default False. When True, perform the operation on the calling object.
                      When False, return a new object.
      :type inplace: bool

      :returns: * DateFrame when `inplace=False`
                * None when `inplace=True`

      .. rubric:: Examples

      Drop column
      >>> df.drop('col_name', axis=1)

      Drop Row
      >>> df.drop(1)
      or
      >>> df.drop(1, axis=0)


   .. py:method:: drop_duplicates(subset=None, keep='first')

      Drops duplcated rows and returns resulting DataFrame.

      If a subset of the columns are provided then only one instance of each
      duplicated row will be returned (keep determines which row).

      :param subset:
      :type subset: Iterable of column names to use to dedupe.
      :param keep: Determines which duplicates (if any) to keep.
      :type keep: {'first', 'last'}, default 'first'

      :returns: DataFrame with duplicates removed.
      :rtype: DataFrame


   .. py:method:: reset_index(size: bool = False, inplace: bool = False) -> Union[None, DataFrame]

      Set the index to an integer range.

      Useful if this dataframe is the result of a slice operation from
      another dataframe, or if you have permuted the rows and no longer need
      to keep that ordering on the rows.

      :param size: If size is passed, do not attempt to determine size based on
                   existing column sizes. Assume caller handles consistency correctly.
      :type size: int
      :param inplace: Default False. When True, perform the operation on the calling object.
                      When False, return a new object.
      :type inplace: bool

      :returns: * DateFrame when `inplace=False`
                * None when `inplace=True`

      .. note::

         Pandas adds a column 'index' to indicate the original index. Arkouda does not currently
         support this behavior.


   .. py:method:: update_size()

      Computes the number of bytes on the arkouda server.


   .. py:method:: rename(mapper: Optional[Union[Callable, Dict]] = None, index: Optional[Union[Callable, Dict]] = None, column: Optional[Union[Callable, Dict]] = None, axis: Union[str, int] = 0, inplace: bool = False) -> Optional[DataFrame]

      Rename indexes or columns according to a mapping.

      :param mapper: Function or dictionary mapping existing values to new values.
                     Nonexistent names will not raise an error.
                     Uses the value of axis to determine if renaming column or index
      :type mapper: callable or dict-like, Optional
      :param column: Function or dictionary mapping existing column names to
                     new column names. Nonexistent names will not raise an
                     error.
                     When this is set, axis is ignored.
      :type column: callable or dict-like, Optional
      :param index: Function or dictionary mapping existing index names to
                    new index names. Nonexistent names will not raise an
                    error.
                    When this is set, axis is ignored
      :type index: callable or dict-like, Optional
      :param axis: Default 0.
                   Indicates which axis to perform the rename.
                   0/"index" - Indexes
                   1/"column" - Columns
      :type axis: int or str
      :param inplace: Default False. When True, perform the operation on the calling object.
                      When False, return a new object.
      :type inplace: bool

      :returns: * DateFrame when `inplace=False`
                * None when `inplace=True`

      .. rubric:: Examples

      >>> df = ak.DataFrame({"A": ak.array([1, 2, 3]), "B": ak.array([4, 5, 6])})
      Rename columns using a mapping
      >>> df.rename(columns={'A':'a', 'B':'c'})
          a   c
      0   1   4
      1   2   5
      2   3   6

      Rename indexes using a mapping
      >>> df.rename(index={0:99, 2:11})
           A   B
      99   1   4
      1   2   5
      11   3   6

      Rename using an axis style parameter
      >>> df.rename(str.lower, axis='column')
          a   b
      0   1   4
      1   2   5
      2   3   6


   .. py:method:: append(other, ordered=True)

      Concatenate data from 'other' onto the end of this DataFrame, in place.

      Explicitly, use the arkouda concatenate function to append the data
      from each column in other to the end of self. This operation is done
      in place, in the sense that the underlying pdarrays are updated from
      the result of the arkouda concatenate function, rather than returning
      a new DataFrame object containing the result.

      :param other: The DataFrame object whose data will be appended to this DataFrame.
      :type other: DataFrame
      :param ordered: If False, allow rows to be interleaved for better performance (but
                      data within a row remains together). By default, append all rows
                      to the end, in input order.
      :type ordered: bool

      :returns: Appending occurs in-place, but result is returned for compatibility.
      :rtype: self


   .. py:method:: concat(items, ordered=True)
      :classmethod:

      Essentially an append, but diffenent formatting


   .. py:method:: head(n=5)

      Return the first `n` rows.

      This function returns the first `n` rows of the the dataframe. It is
      useful for quickly verifying data, for example, after sorting or
      appending rows.

      :param n: Number of rows to select.
      :type n: int

      :returns: The first `n` rows of the DataFrame.
      :rtype: ak.DataFrame

      .. seealso:: :obj:`tail`


   .. py:method:: tail(n=5)

      Return the last `n` rows.

      This function returns the last `n` rows for the dataframe. It is
      useful for quickly testing if your object has the right type of data in
      it.

      :param n: Number of rows to select.
      :type n: int (default=5)

      :returns: The last `n` rows of the DataFrame.
      :rtype: ak.DataFrame

      .. seealso:: :obj:`ak.dataframe.head`


   .. py:method:: sample(n=5)

      Return a random sample of `n` rows.

      :param n: Number of rows to return.
      :type n: int (default=5)

      :returns: The sampled `n` rows of the DataFrame.
      :rtype: ak.DataFrame


   .. py:method:: GroupBy(keys, use_series=False, as_index=True, dropna=True)

      Group the dataframe by a column or a list of columns.

      :param keys: An (ordered) list of column names or a single string to group by.
      :type keys: string or list
      :param use_series: If True, returns an arkouda.dataframe.GroupBy object.
                         Otherwise an arkouda.groupbyclass.GroupBy object.
      :type use_series: bool (default=False)
      :param as_index: If True, groupby columns will be set as index
                       otherwise, the groupby columns will be treated as DataFrame columns.
      :type as_index: bool (default=True)
      :param dropna: If True, and the groupby keys contain NaN values,
                     the NaN values together with the corresponding row will be dropped.
                     Otherwise, the rows corresponding to NaN values will be kept.
      :type dropna: bool (default=True)

      :returns: Either an ak arkouda.groupbyclass.GroupBy or an arkouda.dataframe.GroupBy object.
      :rtype: GroupBy

      .. seealso:: :obj:`arkouda.GroupBy`


   .. py:method:: memory_usage(unit='GB')

      Print the size of this DataFrame.

      :param unit: Unit to return. One of {'KB', 'MB', 'GB'}.
      :type unit: str

      :returns: The number of bytes used by this DataFrame in [unit]s.
      :rtype: int


   .. py:method:: to_pandas(datalimit=maxTransferBytes, retain_index=False)

      Send this DataFrame to a pandas DataFrame.

      :param datalimit: The maximum number size, in megabytes to transfer. The requested
                        DataFrame will be converted to a pandas DataFrame only if the
                        estimated size of the DataFrame does not exceed this value.
      :type datalimit: int (default=arkouda.client.maxTransferBytes)
      :param retain_index: Normally, to_pandas() creates a new range index object. If you want
                           to keep the index column, set this to True.
      :type retain_index: book (default=False)

      :returns: The result of converting this DataFrame to a pandas DataFrame.
      :rtype: pandas.DataFrame


   .. py:method:: to_hdf(path, index=False, columns=None, file_type='distribute')

      Save DataFrame to disk as hdf5, preserving column names.

      :param path: File path to save data
      :type path: str
      :param index: If True, save the index column. By default, do not save the index.
      :type index: bool
      :param columns: List of columns to include in the file. If None, writes out all columns
      :type columns: List
      :param file_type: Default: distribute
                        Whether to save to a single file or distribute across Locales
      :type file_type: str (single | distribute)

      :rtype: None

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray

      .. rubric:: Notes

      This method saves one file per locale of the arkouda server. All
      files are prefixed by the path argument and suffixed by their
      locale number.

      .. seealso:: :obj:`to_parquet`, :obj:`load`


   .. py:method:: update_hdf(prefix_path: str, index=False, columns=None, repack: bool = True)

      Overwrite the dataset with the name provided with this dataframe. If
      the dataset does not exist it is added

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param index: If True, save the index column. By default, do not save the index.
      :type index: bool
      :param columns: List of columns to include in the file. If None, writes out all columns
      :type columns: List
      :param repack: Default: True
                     HDF5 does not release memory on delete. When True, the inaccessible
                     data (that was overwritten) is removed. When False, the data remains, but is
                     inaccessible. Setting to false will yield better performance, but will cause
                     file sizes to expand.
      :type repack: bool

      :rtype: str - success message if successful

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray

      .. rubric:: Notes

      - If file does not contain File_Format attribute to indicate how it was saved,
        the file name is checked for _LOCALE#### to determine if it is distributed.
      - If the dataset provided does not exist, it will be added


   .. py:method:: to_parquet(path, index=False, columns=None, compression: Optional[str] = None, convert_categoricals: bool = False)

      Save DataFrame to disk as parquet, preserving column names.

      :param path: File path to save data
      :type path: str
      :param index: If True, save the index column. By default, do not save the index.
      :type index: bool
      :param columns: List of columns to include in the file. If None, writes out all columns
      :type columns: List
      :param compression: Default None
                          Provide the compression type to use when writing the file.
                          Supported values: snappy, gzip, brotli, zstd, lz4
      :type compression: str (Optional)
      :param convert_categoricals: Defaults to False
                                   Parquet requires all columns to be the same size and Categoricals
                                   don't satisfy that requirement.
                                   if set, write the equivalent Strings in place of any Categorical columns.
      :type convert_categoricals: bool

      :rtype: None

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray

      .. rubric:: Notes

      This method saves one file per locale of the arkouda server. All
      files are prefixed by the path argument and suffixed by their
      locale number.

      .. seealso:: :obj:`to_hdf`, :obj:`load`


   .. py:method:: to_csv(path: str, index: bool = False, columns: Optional[List[str]] = None, col_delim: str = ',', overwrite: bool = False)

              Writes DataFrame to CSV file(s). File will contain a column for each column in the DataFrame.
              All CSV Files written by Arkouda include a header denoting data types of the columns.
              Unlike other file formats, CSV files store Strings as their UTF-8 format instead of storing
              bytes as uint(8).

              Parameters
              -----------
              path: str
                  The filename prefix to be used for saving files. Files will have _LOCALE#### appended
                  when they are written to disk.
              index: bool
                  Defaults to False. If True, the index of the DataFrame will be written to the file
                  as a column
              columns: List[str] (Optional)
                  Column names to assign when writing data
              col_delim: str
                  Defaults to ",". Value to be used to separate columns within the file.
                  Please be sure that the value used DOES NOT appear in your dataset.
              overwrite: bool
                  Defaults to False. If True, any existing files matching your provided prefix_path will
                  be overwritten. If False, an error will be returned if existing files are found.

              Returns
              --------
              None

              Raises
              ------
              ValueError
                  Raised if all datasets are not present in all parquet files or if one or
                  more of the specified files do not exist
              RuntimeError
                  Raised if one or more of the specified files cannot be opened.
                  If `allow_errors` is true this may be raised if no values are returned
                  from the server.
              TypeError
                  Raised if we receive an unknown arkouda_type returned from the server

              Notes
              ------
              - CSV format is not currently supported by load/load_all operations
              - The column delimiter is expected to be the same for column names and data
              - Be sure that column delimiters are not found within your data.
              - All CSV files must delimit rows using newline (`
      `) at this time.



   .. py:method:: read_csv(filename: str, col_delim: str = ',')
      :classmethod:

              Read the columns of a CSV file into an Arkouda DataFrame.
              If the file contains the appropriately formatted header, typed data will be returned.
              Otherwise, all data will be returned as a Strings objects.

              Parameters
              -----------
              filename: str
                  Filename to read data from
              col_delim: str
                  Defaults to ",". The delimiter for columns within the data.

              Returns
              --------
              Arkouda DataFrame containing the columns from the CSV file.

              Raises
              ------
              ValueError
                  Raised if all datasets are not present in all parquet files or if one or
                  more of the specified files do not exist
              RuntimeError
                  Raised if one or more of the specified files cannot be opened.
                  If `allow_errors` is true this may be raised if no values are returned
                  from the server.
              TypeError
                  Raised if we receive an unknown arkouda_type returned from the server

              See Also
              ---------
              to_csv

              Notes
              ------
              - CSV format is not currently supported by load/load_all operations
              - The column delimiter is expected to be the same for column names and data
              - Be sure that column delimiters are not found within your data.
              - All CSV files must delimit rows using newline (`
      `) at this time.
              - Unlike other file formats, CSV files store Strings as their UTF-8 format instead of storing
              bytes as uint(8).




   .. py:method:: save(path, index=False, columns=None, file_format='HDF5', file_type='distribute', compression: Optional[str] = None)

      DEPRECATED
      Save DataFrame to disk, preserving column names.
      :param path: File path to save data
      :type path: str
      :param index: If True, save the index column. By default, do not save the index.
      :type index: bool
      :param columns: List of columns to include in the file. If None, writes out all columns
      :type columns: List
      :param file_format: 'HDF5' or 'Parquet'. Defaults to 'HDF5'
      :type file_format: str
      :param file_type: ("single" | "distribute")
                        Defaults to distribute.
                        If single, will right a single file to locale 0
      :type file_type: str
      :param compression: (None | "snappy" | "gzip" | "brotli" | "zstd" | "lz4")
                          Compression type. Only used for Parquet
      :type compression: str (Optional)

      .. rubric:: Notes

      This method saves one file per locale of the arkouda server. All
      files are prefixed by the path argument and suffixed by their
      locale number.

      .. seealso:: :obj:`to_parquet`, :obj:`to_hdf`


   .. py:method:: load(prefix_path, file_format='INFER')
      :classmethod:

      Load dataframe from file
      file_format needed for consistency with other load functions


   .. py:method:: argsort(key, ascending=True)

      Return the permutation that sorts the dataframe by `key`.

      :param key: The key to sort on.
      :type key: str

      :returns: The permutation array that sorts the data on `key`.
      :rtype: ak.pdarray


   .. py:method:: coargsort(keys, ascending=True)

      Return the permutation that sorts the dataframe by `keys`.

      Sorting using Strings may not yield correct results

      :param keys: The keys to sort on.
      :type keys: list

      :returns: The permutation array that sorts the data on `keys`.
      :rtype: ak.pdarray


   .. py:method:: sort_index(ascending=True)

      Sort the DataFrame by indexed columns.

      Note: Fails on sorting ak.Strings when multiple columns being sorted

      :param ascending: Sort values in ascending (default) or descending order.
      :type ascending: bool


   .. py:method:: sort_values(by=None, ascending=True)

      Sort the DataFrame by one or more columns.

      If no column is specified, all columns are used.

      Note: Fails on sorting ak.Strings when multiple columns being sorted

      :param by: The name(s) of the column(s) to sort by.
      :type by: str or list/tuple of str
      :param ascending: Sort values in ascending (default) or descending order.
      :type ascending: bool

      .. seealso:: :obj:`apply_permutation`, :obj:`sorted`


   .. py:method:: apply_permutation(perm)

      Apply a permutation to an entire DataFrame.

      This may be useful if you want to unsort an DataFrame, or even to
      apply an arbitrary permutation such as the inverse of a sorting
      permutation.

      :param perm: A permutation array. Should be the same size as the data
                   arrays, and should consist of the integers [0,size-1] in
                   some order. Very minimal testing is done to ensure this
                   is a permutation.
      :type perm: ak.pdarray

      .. seealso:: :obj:`sort`


   .. py:method:: filter_by_range(keys, low=1, high=None)

      Find all rows where the value count of the items in a given set of
      columns (keys) is within the range [low, high].

      To filter by a specific value, set low == high.

      :param keys: The names of the columns to group by
      :type keys: list or str
      :param low: The lowest value count.
      :type low: int (default=1)
      :param high: The highest value count, default to unlimited.
      :type high: int (default=None)

      :returns: An array of boolean values for qualified rows in this DataFrame.
      :rtype: pdarray

      .. seealso:: :obj:`filter_by_count`


   .. py:method:: copy(deep=True)

      Make a copy of this object's data.

      When `deep = True` (default), a new object will be created with a copy of
      the calling object's data. Modifications to the data of the copy will not
      be reflected in the original object.


      When `deep = False` a new object will be created without copying the
      calling object's data. Any changes to the data of the original object will
      be reflected in the shallow copy, and vice versa.

      :param deep: When True, return a deep copy. Otherwise, return a shallow copy.
      :type deep: bool (default=True)

      :returns: A deep or shallow copy according to caller specification.
      :rtype: aku.DataFrame


   .. py:method:: groupby(keys, use_series=True, as_index=True, dropna=True)

      Group the dataframe by a column or a list of columns.  Alias for GroupBy

      :param keys: a single column name or a list of column names
      :type keys: str or list(str)
      :param use_series: Change return type to Arkouda Groupby object.
      :type use_series: bool (default = True)
      :param as_index: If true groupby aggregation values will be treated as an index.
                       Otherwise, the groupby values will be treated as DataFrame column(s).
      :type as_index: bool (default=True)
      :param dropna: If True, and the groupby keys contain NaN values,
                     the NaN values together with the corresponding row will be dropped.
                     Otherwise, the rows corresponding to NaN values will be kept.
      :type dropna: bool (default=True)

      :rtype: An arkouda Groupby instance


   .. py:method:: isin(values: Union[arkouda.pdarrayclass.pdarray, Dict, arkouda.series.Series, DataFrame]) -> DataFrame

      Determine whether each element in the DataFrame is contained in values.

      :param values: The values to check for in DataFrame. Series can only have a single index.
      :type values: pdarray, dict, Series, or DataFrame

      :returns: Arkouda DataFrame of booleans showing whether each element in the DataFrame is
                contained in values
      :rtype: DataFrame

      .. seealso:: :obj:`ak.Series.isin`

      .. rubric:: Notes

      - Pandas supports values being an iterable type. In arkouda, we replace this with pdarray
      - Pandas supports ~ operations. Currently, ak.DataFrame does not support this.

      .. rubric:: Examples

      >>> df = ak.DataFrame({'col_A': ak.array([7, 3]), 'col_B':ak.array([1, 9])})
      >>> df
          col_A  col_B
      0      7      1
      1      3      9 (2 rows x 2 columns)

      When `values` is a pdarray, check every value in the DataFrame to determine if
      it exists in values
      >>> df.isin(ak.array([0, 1]))
         col_A  col_B
      0  False   True
      1  False  False (2 rows x 2 columns)

      When `values` is a dict, the values in the dict are passed to check the column
      indicated by the key
      >>> df.isin({'col_A': ak.array([0, 3])})
          col_A  col_B
      0  False  False
      1   True  False (2 rows x 2 columns)

      When `values` is a Series, each column is checked if values is present positionally.
      This means that for `True` to be returned, the indexes must be the same.
      >>> i = ak.Index(ak.arange(2))
      >>> s = ak.Series(data=[3, 9], index=i)
      >>> df.isin(s)
          col_A  col_B
      0  False  False
      1  False   True (2 rows x 2 columns)

      When `values` is a DataFrame, the index and column must match.
      Note that 9 is not found because the column name does not match.
      >>> other_df = ak.DataFrame({'col_A':ak.array([7, 3]), 'col_C':ak.array([0, 9])})
      >>> df.isin(other_df)
          col_A  col_B
      0   True  False
      1   True  False (2 rows x 2 columns)


   .. py:method:: corr() -> DataFrame

      Return new DataFrame with pairwise correlation of columns

      :returns: Arkouda DataFrame containing correlation matrix of all columns
      :rtype: DataFrame

      :raises RuntimeError: Raised if there's a server-side error thrown

      .. seealso:: :obj:`pdarray.corr`

      .. rubric:: Notes

      Generates the correlation matrix using Pearson R for all columns

      Attempts to convert to numeric values where possible for inclusion in the matrix.


   .. py:method:: merge(right: DataFrame, on: Optional[Union[str, List[str]]] = None, how: str = 'inner', left_suffix: str = '_x', right_suffix: str = '_y') -> DataFrame

      Utilizes the ak.join.inner_join_merge and the ak.join.right_join_merge
      functions to return a merged Arkouda DataFrame object
      containing rows from both DataFrames as specified by the merge
      condition (based on the "how" and "on" parameters). For this function self
      is considered the left dataframe.
      Based on pandas merge functionality.
      https://github.com/pandas-dev/pandas/blob/main/pandas/core/reshape/merge.py#L137

      :param right: The Right DataFrame to be joined
      :type right: DataFrame
      :param on: The name or list of names of the DataFrame column(s) to join on.
                 If on is None, this defaults to the intersection of the columns in both DataFrames.
      :type on: Optional[Union[str, List[str]]] = None
      :param how: The merge condition.
                  Must be "inner", "left", or "right"
      :type how: str = "inner",
      :param left_suffix: A string indicating the suffix to add to columns from the left dataframe for overlapping
                          column names in both left and right. Defaults to "_x". Only used when how is "inner"
      :type left_suffix: str = "_x"
      :param right_suffix: A string indicating the suffix to add to columns from the right dataframe for overlapping
                           column names in both left and right. Defaults to "_y". Only used when how is "inner"
      :type right_suffix: str = "_y"

      :returns: * *DataFrame* -- Joined Arkouda DataFrame
                * **Note** (*Multiple column joins are only supported for integer columns*)


   .. py:method:: register(user_defined_name: str) -> DataFrame

      Register this DataFrame object and underlying components with the Arkouda server

      :param user_defined_name: user defined name the DataFrame is to be registered under,
                                this will be the root name for underlying components
      :type user_defined_name: str

      :returns: The same DataFrame which is now registered with the arkouda server and has an updated name.
                This is an in-place modification, the original is returned to support a
                fluid programming style.
                Please note you cannot register two different DataFrames with the same name.
      :rtype: DataFrame

      :raises TypeError: Raised if user_defined_name is not a str
      :raises RegistrationError: If the server was unable to register the DataFrame with the user_defined_name

      .. seealso:: :obj:`unregister`, :obj:`attach`, :obj:`unregister_dataframe_by_name`, :obj:`is_registered`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.

      Any changes made to a DataFrame object after registering with the server may not be reflected
      in attached copies.


   .. py:method:: unregister()

      Unregister this DataFrame object in the arkouda server which was previously
      registered using register() and/or attached to using attach()

      :raises RegistrationError: If the object is already unregistered or if there is a server error
          when attempting to unregister

      .. seealso:: :obj:`register`, :obj:`attach`, :obj:`unregister_dataframe_by_name`, :obj:`is_registered`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.


   .. py:method:: is_registered() -> bool

      Return True if the object is contained in the registry

      :returns: Indicates if the object is contained in the registry
      :rtype: bool

      :raises RegistrationError: Raised if there's a server-side error or a mismatch of registered components

      .. seealso:: :obj:`register`, :obj:`attach`, :obj:`unregister`, :obj:`unregister_dataframe_by_name`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.


   .. py:method:: attach(user_defined_name: str) -> DataFrame
      :staticmethod:

      Function to return a DataFrame object attached to the registered name in the
      arkouda server which was registered using register()

      :param user_defined_name: user defined name which DataFrame object was registered under
      :type user_defined_name: str

      :returns: The DataFrame object created by re-attaching to the corresponding server components
      :rtype: DataFrame

      :raises RegistrationError: if user_defined_name is not registered

      .. seealso:: :obj:`register`, :obj:`is_registered`, :obj:`unregister`


   .. py:method:: unregister_dataframe_by_name(user_defined_name: str) -> None
      :staticmethod:

      Function to unregister DataFrame object by name which was registered
      with the arkouda server via register()

      :param user_defined_name: Name under which the DataFrame object was registered
      :type user_defined_name: str

      :raises TypeError: if user_defined_name is not a string
      :raises RegistrationError: if there is an issue attempting to unregister any underlying components

      .. seealso:: :obj:`register`, :obj:`unregister`, :obj:`attach`, :obj:`is_registered`


   .. py:method:: from_return_msg(rep_msg)
      :classmethod:



.. py:function:: sorted(df, column=False)

   Analogous to other python 'sorted(obj)' functions in that it returns
   a sorted copy of the DataFrame.

   If no sort key is specified, sort by the first key returned.

   Note: This fails on sorting ak.Strings, as does DataFrame.sort().

   :param df: The DataFrame to sort.
   :type df: ak.dataframe.DataFrame
   :param column: The name of the column to sort by.
   :type column: str

   :returns: A sorted copy of the original DataFrame.
   :rtype: ak.dataframe.DataFrame


.. py:function:: intx(a, b)

   Find all the rows that are in both dataframes. Columns should be in
   identical order.

   Note: does not work for columns of floating point values, but does work for
   Strings, pdarrays of int64 type, and Categorical *should* work.


.. py:function:: intersect(a, b, positions=True, unique=False)

   Find the intersection of two arkouda arrays.

   This function can be especially useful when `positions=True` so
   that the caller gets the indices of values present in both arrays.

   :param a: An array of strings
   :type a: ak.Strings or ak.pdarray
   :param b: An array of strings
   :type b: ak.Strings or ak.pdarray
   :param positions: Return tuple of boolean pdarrays that indicate positions in a and b
                     where the values are in the intersection.
   :type positions: bool (default=True)
   :param unique: If the number of distinct values in `a` (and `b`) is equal to the size of
                  `a` (and `b`), there is a more efficient method to compute the intersection.
   :type unique: bool (default=False)

   :returns: The indices of `a` and `b` where any element occurs at least once in both
             arrays.
   :rtype: (ak.pdarray, ak.pdarray)


.. py:function:: invert_permutation(perm)

   Find the inverse of a permutation array.

   :param perm: The permutation array.
   :type perm: ak.pdarray

   :returns: The inverse of the permutation array.
   :rtype: ak.pdarray


.. py:function:: merge(left: DataFrame, right: DataFrame, on: Optional[Union[str, List[str]]] = None, how: str = 'inner', left_suffix: str = '_x', right_suffix: str = '_y') -> DataFrame

   Utilizes the ak.join.inner_join_merge and the ak.join.right_join_merge
   functions to return a merged Arkouda DataFrame object
   containing rows from both DataFrames as specified by the merge
   condition (based on the "how" and "on" parameters).
   Based on pandas merge functionality.
   https://github.com/pandas-dev/pandas/blob/main/pandas/core/reshape/merge.py#L137
   :param left: The Left DataFrame to be joined
   :type left: DataFrame
   :param right: The Right DataFrame to be joined
   :type right: DataFrame
   :param on: The name or list of names of the DataFrame column(s) to join on.
              If on is None, this defaults to the intersection of the columns in both DataFrames.
   :type on: Optional[Union[str, List[str]]] = None
   :param how: The merge condition.
               Must be one of "inner", "left", or "right"
   :type how: str = "inner"
   :param left_suffix: A string indicating the suffix to add to columns from the left dataframe for overlapping
                       column names in both left and right. Defaults to "_x". Only used when how is "inner"
   :type left_suffix: str = "_x"
   :param right_suffix: A string indicating the suffix to add to columns from the right dataframe for overlapping
                        column names in both left and right. Defaults to "_y". Only used when how is "inner"
   :type right_suffix: str = "_y"

   :returns: * *DataFrame* -- Joined Arkouda DataFrame
             * **Note** (*Multiple column joins are only supported for integer columns*)


